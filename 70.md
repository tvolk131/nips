# NIP-70

## Nostr capability over IPC

`draft` `optional`

We define a standard protocol for two types of applications running on the same computer to communicate with each other. One type acts like a server (which we will call a **server app**), the other acts like a client (which we will call a **client app**). A **server app** can receive requests from **client apps** and send responses back. Only one **server app** can be running on a given machine, since it binds to a socket with a fixed standard name, but multiple **client apps** can be running and make simultaneous requests. This is similar to NIP-07 but for desktop applications rather than a web browser.

## RPCs

We define a set of request/response remote procedure calls (RPCs) that a **client app** can make to a **server app**. The following RPCs MUST be implemented by a **server app** and MAY be called by a **client app**:

- `registerApplication`
  Register a client application with the server. This SHOULD only be called in response to the user clicking a button on the client application with the text "_Sign in with Key Manager_".

  TODO: How should a client become aware of and handle the **server app** purging its nApi key?

  Request: application name (should not be trusted by NIP-70 server), as well as suggested API permissions
  Response: nApi key that SHOULD be stored by the client application and SHOULD be used in all subsequent request by the application
  TODO: Should the response include an nPub so that the client application doesn't need to immediately call `getPublicKey`? What if the client application plans to use `getPublicKeys` instead, and do its own identity management?

  Example request: `{"applicationName": "Damus"}`
  Example response: `{"nApiKey": "nApi12345678"}`

- `getPublicKeys` (TODO: Do we need this, or the RPC below?)
  Returns all public keys that the server has the private keys for.

- `getPublicKey`
  Returns the public key of the identity currently linked to the client application based on its included nApi key

  Example request: `undefined`
  Example response: `{"nPub": "71f6fb912ffc566876414b52bff3bbb7856ad2daa584f5163ffdb41bdca341c3"}`

- `signEvent`
  Request: NIP-01 unsigned event
  Response: NIP-01 event

- `getRelays`

## RPC Protocol

### Message Layer

We use [JSON-RPC 2.0](https://www.jsonrpc.org/specification) as the RPC protocol. A **server app** MUST support batching as defined in the spec. Note: Notifications are not used.

### Transport Layer

For the transport layer we use Unix domain sockets (UDS) on Linux and MacOS, and Named Pipes on Windows. UDS and Named Pipes are both exclusive to their respective platforms, but behave in similar ways.

Sending messages over sockets introduces a problem. Since a socket is just a stream of bytes, how do we know when an incoming message (whether a request from a client or a response from a server) is complete? [This proposal](https://www.simple-is-better.org/json-rpc/transport_sockets.html) discusses three different options for delimiting JSON-RPC 2.0 messages where a socket is used as the transport layer. We use the first proposed option: **shutdown/close after every Request/Response**:

```
Client-side:
1. open a socket, connect
2. send Request, shutdown socket-writing
3. receive Response (=receive until close/shutdown)
4. close socket

Server-side:
0. open socket, bind, listen
1. accept a connection
2. receive Request (=receive until shutdown)
3. send Response
4. close connection
```

We use this option because it avoids long-lived connections. The downside is that a new connection is required for each request, which is slower when a high throughput of requests are made. However, we don't expect a high throughput of requests, and the avoidance of long-lived connections simplifies implementation since there is no state that needs to be managed beyond the lifecycle of an individual request and response.

TODO: Figure out if this option will work with Named Pipes. If not, we can always go with the second option (netstrings). If we go with the second option. However, this will introduce the added complexity of long-lived connections.

#### Unix IPC (UDS)

A Unix domain socket is opened at the following path:

The following UDS path MUST be used:

`/tmp/nip-70.sock`

A server app MUST call `bind()` on this address and repeatedly call `accept()` on all incoming connections.

#### Windows IPC (Named Pipes)

TODO: Define spec using Named Pipes. We haven't yet had a chance to test this out at all on Windows yet.

## Reference Implementations

### Rust Crate

We have a reference implementation of this NIP written in Rust that can be found [here](https://crates.io/crates/nip-70). This crate implements a server and client API.

### Server App

We are currently building a desktop app called [Keystache](https://github.com/Resolvr-io/Keystache) that acts as a NIP-70 server.

To build your own NIP-70 compliant app, just start up Keystache and use the client functions in the Rust crate mentioned above. We recommend using [Tauri](https://tauri.app/) for building desktop app. It's written in Rust and allows for a JS/TS-based UI, so you can use the web tools/frameworks you already use such as React. Keystache uses Tauri, feel free to use it as a reference.
