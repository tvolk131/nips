# NIP-70

## Nostr capability over IPC

`draft` `optional`

This is essentially NIP-07 but for desktop applications. We define a standard protocol for two types of applications running on the same computer to communicate with each other. One type acts like a server (which we will call a **server app**), the other acts like a client (which we will call a **client app**). A **server app** can receive requests from **client apps** and send responses back. Only one **server app** can be running on a given machine, since it binds to a socket with a fixed standard name, but multiple **client apps** can be running and make simultaneous requests.

### Message Encoding

We define a set of request/response remote procedure calls (RPCs) that a **client app** can make to a **server app**. We use [JSON-RPC 2.0](https://www.jsonrpc.org/specification) as the RPC protocol. For the transport layer we use Unix domain sockets (UDS) on Linux and MacOS, and Named Pipes on Windows. UDS and Named Pipes are both exclusive to their respective platforms, but behave in similar ways.

The JSON-RPC 2.0 spec defines request batching where a client can send an array of request objects. A **server app** MUST support request batching.

#### Message Delimiting

[This proposal](https://www.simple-is-better.org/json-rpc/transport_sockets.html) discusses three different options for delimiting JSON-RPC 2.0 messages where a socket is used as the transport layer. We use the first proposed option: **shutdown/close after every Request/Response**.

### RPCs

The following remote procedure calls (RPCs) can be made by a **client app**, and a **server app** MUST implement all of these:

- `registerApplication`
  Register a client application with the server. This SHOULD only be called in response to the user clicking a button on the client application with the text "_Sign in with Key Manager_".

  TODO: How should a client become aware of and handle the key server purging its nApi key?

  Request: application name (should not be trusted by NIP-70 server), as well as suggested API permissions
  Response: nApi key that SHOULD be stored by the client application and SHOULD be used in all subsequent request by the application
  TODO: Should the response include an nPub so that the client application doesn't need to immediately call `getPublicKey`? What if the client application plans to use `getPublicKeys` instead, and do its own identity management?

  Example request: `{"applicationName": "Damus"}`
  Example response: `{"nApiKey": "nApi12345678"}`

- `getPublicKeys` (TODO: Do we need this, or the RPC below?)
  Returns all public keys that the server has the private keys for.

- `getPublicKey`
  Returns the public key of the identity currently linked to the client application based on its included nApi key

  Example request: `undefined`
  Example response: `{"nPub": "71f6fb912ffc566876414b52bff3bbb7856ad2daa584f5163ffdb41bdca341c3"}`

- `signEvent`
  Request: NIP-01 unsigned event
  Response: NIP-01 event

- `getRelays`

### Unix IPC (UDS)

A Unix domain socket is opened at the following path:

The following UDS path MUST be used:

`/tmp/nip-70.sock`

A server app MUST call `bind()` on this address and repeatedly call `accept()` on all incoming connections.

### Windows IPC (Named Pipes)

TODO: Define spec using Named Pipes. We haven't yet had a chance to test this out at all on Windows yet.

### Reference Implementations

#### Rust Crate

We have a reference implementation of this NIP written in Rust that can be found [here](https://crates.io/crates/nip-70). This crate implements a server and client API.

#### Server App

We are currently building a desktop app called [Keystache](https://github.com/Resolvr-io/Keystache) that acts as a NIP-70 server.

To build your own NIP-70 compliant app, just start up Keystache and use the client functions in the Rust crate mentioned above. We recommend using [Tauri](https://tauri.app/) for building desktop app. It's written in Rust and allows for a JS/TS-based UI, so you can use the web tools/frameworks you already use such as React. Keystache uses Tauri, feel free to use it as a reference.
